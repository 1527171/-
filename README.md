# 供应链优化系统文档

## 目录

### 数据加载模块
- [`load_data()`](#load_data-函数) - 从本地Excel加载数据
- [`load_data_from_db(db_path)`](#load_data_from_db-函数) - 从SQLite数据库加载数据

### 订单处理模块
- [`get_orders(orders)`](#get_orders-函数) - 提取并验证订单数据

### 仓库选择模块
- [`select_repos(orders, goods, trans)`](#select_repos-函数) - 筛选候选仓库
- [`structure_data(candidate_repos)`](#structure_data-函数) - 生成邻接矩阵

### 路径优化模块
- [`find_minimal_cover(adjacency_matrix)`](#find_minimal_cover-函数) - 寻找最小覆盖集
- [`calculate_cost(count, trans_record)`](#calculate_cost-函数) - 计算单项成本
- [`output_best_routes(...)`](#output_best_routes-函数) - 输出最优方案
### 结果示例
- [结果示例](#result-example)
---



## 函数详细说明

### `load_data()` 函数 <a id="load_data-函数"></a>
#### 功能描述
1. **核心功能**：
   - 从本地Excel文件加载供应链管理相关的4个核心数据表（库存表、购买表、运输表、物品表）
   - 用于构建供应链数据分析的基础数据环境

2. **安全机制**：
   - 前置校验所有必需文件是否存在
   - 后置校验数据完整性（空数据检测）
   - 防御性编程设计保障数据管道可靠性

#### 参数说明
- 无显式参数（隐式依赖当前目录环境）

#### 返回值
- 返回元组 (goods, orders, trans, name)
- 数据表对应关系：
  | 变量名 | 表内容           | 数据结构  |
  |--------|------------------|-----------|
  | goods  | 库存状态数据     | DataFrame |
  | orders | 采购订单记录     | DataFrame |
  | trans  | 物流运输信息     | DataFrame |
  | name   | 物品主数据       | DataFrame |

#### 异常机制
- 文件缺失时抛出 FileNotFoundError
- 空数据时抛出 ValueError
- 典型应用场景：供应链分析系统初始化时的数据加载

---




### `load_data_from_db()` 函数 <a id="load_data_from_db-函数"></a>

#### 功能描述
1. **核心功能**：
   - 从SQLite数据库加载相同业务维度的数据
   - 支持数据库化的数据存储方案
   - 适用于企业级数据管理场景

2. **安全机制**：
   - 数据库连接状态管理（自动关闭连接）
   - 多表数据完整性校验
   - 统一的异常捕获与转换

#### 参数说明
| 参数名  | 类型   | 必填 | 说明                      |
|---------|--------|------|---------------------------|
| db_path | str    | 是   | SQLite数据库文件物理路径  |

#### 返回值
- 返回元组 (库存表DF, 购买表DF, 运输表DF, 物品表DF)
- 数据结构与load_data()完全一致

#### 异常机制
- 数据库文件缺失时抛出 FileNotFoundError
- 空表检测抛出 ValueError
- 通用数据库错误包装为 RuntimeError
- 典型应用场景：数据库迁移或云端数据同步

---
### `get_orders()` 函数 <a id="get_orders-函数"></a>

#### 功能描述
1. **核心功能**：
   - 从输入的订单数据中提取并验证关键字段信息，确保数据格式和内容的有效性。
   - 为供应链管理系统（如运输调度、库存分配）提供预处理后的订单基础数据。
   - 默认提取前5条有效订单（或更少，若总订单量不足5条），支持小批量处理场景。

2. **安全机制**：
   - **数据完整性校验**：检查输入数据是否存在空值或缺失关键列。
   - **数据格式校验**：对每个字段进行类型和取值范围验证，确保符合业务逻辑。
   - **数据裁剪机制**：自动限制输出数据量，防止内存溢出或处理过载。

---

#### 参数说明
| 参数名   | 类型          | 必填 | 说明                                |
|----------|---------------|------|-------------------------------------|
| orders   | pandas.DataFrame | 是   | 原始订单数据表，需包含指定业务字段  |

---

#### 返回值
返回元组 `(orders_items, orders_destination, orders_counts, orders_time)`，包含以下四个列表：

| 字段名               | 数据类型       | 业务含义                     | 值域要求                  |
|----------------------|----------------|------------------------------|--------------------------|
| orders_items         | List[Union[int, str]] | 商品唯一标识列表       | 非空，支持整型/字符串     |
| orders_destination   | List[str]             | 配送地址列表           | 非空字符串               |
| orders_counts        | List[Union[int, float]] | 订购数量列表           | 正实数（>0）             |
| orders_time          | List[Union[int, float]] | 订单时效要求列表       | 正实数（>0，单位依业务定）|

---
### `select_repos()` 函数 <a id="select_repos-函数"></a>


#### **功能描述**
该函数是供应链调度系统的核心模块，**基于订单需求、库存分布和运输成本，筛选出满足时间约束且运输成本最低的候选仓库集合**。具体实现以下关键逻辑：

1. **输入验证**  
   确保订单、库存、运输三张主数据表均合法有效：
   - 检查数据表是否为空
   - 验证各表是否包含业务必需字段
   - 字段缺失或数据为空时立即终止处理

2. **订单处理**  
   遍历每个订单项（`物品编号`），执行以下操作：
   - 从库存表中筛选该物品的所有库存记录
   - 对每个库存地，验证库存数量和发货时间的有效性
   - 结合运输数据，计算从库存地到订单目的地的 **总时效**（发货时间 + 运输所需时间）
   - 筛选满足订单时限要求且库存充足的候选仓库

3. **成本优化**  
   对满足时效条件的运输路线：
   - 选择 **运输成本最低** 的运输途径
   - 确保每个库存地仅保留最优运输方案（避免重复记录）
   - 合并所有订单项的候选仓库，生成全局优化结果

---

#### **参数说明**
| 参数名   | 类型               | 必填 | 说明                                                                 |
|----------|--------------------|------|----------------------------------------------------------------------|
| orders   | pandas.DataFrame   | 是   | 订单数据表，包含物品需求、配送要求等核心字段                         |
| goods    | pandas.DataFrame   | 是   | 库存分布表，记录各仓库的物品库存及本地操作时间                       |
| trans    | pandas.DataFrame   | 是   | 运输路线表，存储不同运输路径的时效、成本及仓储费用                   |

**输入表字段要求**  
| 表类型   | 必需字段                                                                           |
|----------|------------------------------------------------------------------------------------|
| orders   | `["物品编号", "目的地", "购买数量", "时限"]`                                       |
| goods    | `["物品编号", "库存地", "数量", "发货时间"]`                                       |
| trans    | `["始发地", "目的地", "所需时间（小时）", "目的地仓储成本（元）", "运输成本（元）", "运输途径"]` |

---

#### **返回值**
返回一个 **候选仓库数据框** (`pandas.DataFrame`)，结构如下：  

| 字段名                | 数据类型 | 业务含义                                                                 |
|-----------------------|----------|--------------------------------------------------------------------------|
| 物品编号              | object   | 订单需求的物品唯一标识                                                   |
| 始发地                | object   | 候选仓库所在位置                                                         |
| 目的地                | object   | 订单指定的配送地址                                                       |
| 库存                  | numeric  | 当前仓库中该物品的可供应量                                               |
| 所需时间（小时）      | numeric  | **总时效** = 仓库发货时间 + 运输所需时间（需 ≤ 订单时限）                |
| 目的地仓储成本（元）  | numeric  | 目的地仓储费用（可能影响后续仓储决策）                                   |
| 运输成本（元）        | numeric  | **当前筛选的最优运输成本**（同一始发地可能有多条运输途径，仅保留最低成本）|
| 运输途径              | object   | 采用的运输方式（如飞机、火车、汽车）                                     |

---

#### **核心逻辑详解**
1. **数据预处理**  
   调用 `get_orders()` 提取订单关键字段，验证字段有效性（见前序代码分析）。

2. **库存匹配**  
   ```python
   select_item = goods[goods["物品编号"] == item]
   ```
   按订单物品编号过滤库存表，若无库存记录则跳过该订单项。

3. **运输路径筛选**  
   ```python
   trans_filtered = trans[(trans["始发地"] == stock_loc) & (trans["目的地"] == destination)]
   valid_trans = trans_filtered[trans_filtered["所需时间（小时）"] + dispatch_time <= time_limit]
   ```
   筛选从库存地到订单目的地的运输路线，并验证总时效是否满足订单要求。

4. **成本优化选择**  
   ```python
   min_cost_trans = valid_trans.loc[valid_trans["运输成本（元）"].idxmin()]
   ```
   在满足时效的运输记录中，选择运输成本最低的一条作为候选方案。

5. **候选仓库合并**  
   通过 `candidates` 字典确保每个库存地仅保留最优运输方案，最终将所有订单项的候选结果合并为统一数据框。

---

#### **示例结果解析**
以输出结果中的部分记录为例：

| 物品编号 | 始发地   | 目的地   | 库存 | 所需时间 | 仓储成本 | 运输成本 | 运输途径 |
|----------|----------|----------|------|----------|----------|----------|----------|
| Item66   | 沈阳市   | 张家口市 | 35   | 8.03     | 11.41    | 23.620   | 飞机     |
| Item66   | 邯郸市   | 张家口市 | 92   | 8.11     | 11.41    | 56.800   | 飞机     |
| Item66   | 石家庄市 | 张家口市 | 69   | 17.51    | 11.41    | 15.740   | 火车     |

- **业务含义**：针对 `Item66` 的订单，系统筛选出三个候选仓库：
  - 沈阳市：运输成本较高（23.62元），但时效最短（8.03小时）
  - 石家庄市：运输成本最低（15.74元），但时效最长（17.51小时）
  - 后续调度系统可根据业务策略（成本优先或时效优先）选择最终方案

- **数据验证**：
  - 所有 `所需时间` ≤ 订单时限
  - 同一始发地的多条运输途径（如不同运输方式）已被过滤，仅保留成本最低的一条

### `structure_data()` 函数 <a id="structure_data-函数"></a>


#### **功能描述**
该函数是供应链优化算法的数据预处理模块，**将候选仓库与物品的可达性关系编码为邻接矩阵**，为后续的路径优化、库存分配等计算提供结构化输入。核心功能包括：

1. **可达性建模**  
   将分散的候选仓库记录转化为 **二元关系矩阵**，明确标识：
   - 每个物品（行）可以从哪些仓库（列）发货
   - 矩阵元素值为 `1` 表示允许从该仓库发货，`0` 表示不可用

2. **数据结构化**  
   生成标准的二维矩阵，适配运筹学算法（如整数规划、图论算法）的输入格式要求

3. **数据压缩**  
   通过稀疏矩阵表示（0/1值）减少冗余数据存储，提升计算效率

---

#### **参数说明**
| 参数名           | 类型               | 必填 | 说明                                                                 |
|------------------|--------------------|------|----------------------------------------------------------------------|
| candidate_repos  | pandas.DataFrame   | 是   | `select_repos()` 函数输出的候选仓库数据表，需包含始发地和物品编号字段 |

**输入表字段要求**  
- 必需列：`["始发地", "物品编号"]`
- 其他列（如运输成本、库存量）在本函数中不参与计算，但需确保输入数据经过前置筛选

---

#### **返回值**
返回一个 **邻接矩阵** (`pandas.DataFrame`)，具体结构如下：

| 维度   | 说明                  | 数据类型       | 示例值         |
|--------|-----------------------|----------------|----------------|
| 行索引 | 物品编号列表          | Index(str)     | `Item66, Item99` |
| 列名   | 仓库名称列表          | Columns(str)   | `沈阳市, 邯郸市`  |
| 元素值 | 可达性标记 (0/1)      | int            | `1` 表示允许从该仓库发货 |

**示例输出解析**：
```python
        沈阳市  邯郸市  石家庄市  深圳市  ...  
Item66    1    1     1    0    ...  
Item99    0    1     0    1    ...  
```
- **Item66** 可从 `沈阳市`、`邯郸市`、`石家庄市` 发货
- **Item99** 可从 `邯郸市`、`深圳市` 等仓库发货

---

#### **核心逻辑详解**
1. **输入校验**  
   ```python
   if candidate_repos.empty: raise ValueError(...)
   for col in required_columns: check column exists
   ```
   - 防御性校验避免无效输入导致后续计算崩溃

2. **维度提取**  
   ```python
   reposs = candidate_repos["始发地"].unique()  # 所有唯一仓库
   items = candidate_repos["物品编号"].unique()  # 所有唯一物品
   ```
   - 通过去重操作确保矩阵维度正确性

3. **矩阵初始化**  
   ```python
   adjacency_matrix = pd.DataFrame(0, index=items, columns=reposs)
   ```
   - 创建全零矩阵，预设所有仓库-物品组合不可达

4. **关系标记**  
   ```python
   for _, row in candidate_repos.iterrows():
       item = row["物品编号"]
       repos = row["始发地"]
       adjacency_matrix.loc[item, repos] = 1  # 标记可达
   ```
   - 遍历候选记录，激活有效仓库-物品组合

---

#### **与下游计算的关系**
此矩阵将作为以下算法的核心输入：
1. **运输成本优化**  
   结合运输成本矩阵，求解总成本最低的仓库-物品分配方案  
   **数学模型**：  
   ```
   Minimize Σ (Transport_Cost_ij * X_ij)  
   Subject to X_ij ∈ {0,1} 且 X_ij ≤ Adjacency_Matrix_ij
   ```

2. **库存平衡校验**  
   验证各仓库的分配量不超过实际库存  
   **约束条件**：  
   ```
   Σ (Order_Qty_i * X_ij) ≤ Stock_Qty_j  (∀j)
   ```

3. **多目标优化**  
   在时效、成本、仓储费用等多维度约束下寻找帕累托最优解

---

#### **异常处理说明**
| 异常类型                 | 触发条件                          | 处理方式                   |
|--------------------------|-----------------------------------|----------------------------|
| ValueError               | 输入数据为空                      | 终止流程，提示数据质量问题 |
| KeyError                 | 缺少 `始发地` 或 `物品编号` 列     | 中断计算，要求检查数据源   |
| 隐式错误                 | 同一仓库-物品组合重复标记         | 最终值始终为1（幂等设计）  |



### `find_minimal_cover()` 函数 <a id="find_minimal_cover-函数"></a>


#### **功能描述**
该函数是供应链网络优化的核心算法模块，**基于回溯法+贪心剪枝策略，解决最小仓库覆盖问题**，即在保证所有物品可被发货的前提下，找到需要启用的最少仓库集合。核心特性如下：

1. **多目标优化**  
   同时满足：
   - **覆盖完整性**：所有物品至少有一个仓库可供应
   - **仓库数量最少**：最小化运营成本
   - **全解空间搜索**：返回所有可能的最小覆盖组合（如示例中的3个候选方案）

2. **算法优化**  
   - **回溯法框架**：穷举仓库组合可能性
   - **贪心剪枝**：优先选择覆盖能力最强的仓库，大幅减少搜索空间
   - **状态缓存**：通过 `visited` 集合避免重复计算相同状态

---

#### **参数说明**
| 参数名             | 类型               | 必填 | 说明                                                                 |
|--------------------|--------------------|------|----------------------------------------------------------------------|
| adjacency_matrix   | pandas.DataFrame   | 是   | `structure_data()` 生成的邻接矩阵，表示仓库-物品可达性关系           |

**输入矩阵要求**：
- 行索引为物品编号（如 `Item66`）
- 列名为仓库名称（如 `沈阳市`）
- 元素值为 `0/1`，标识仓库是否支持该物品

---

#### **返回值**
返回 **最小覆盖仓库集合的列表**，每个元素是一个仓库名称列表，代表一种最优方案。  
**示例输出**：
```python
[
    ['沈阳市', '秦皇岛市', '乌海市'], 
    ['沈阳市', '秦皇岛市', '营口市'], 
    ['沈阳市', '秦皇岛市', '运城市']
]
```
- **共同特征**：所有方案均只需3个仓库即可覆盖全部物品
- **业务价值**：为决策者提供多个备选方案，可结合其他成本维度二次筛选

---

### **算法核心逻辑详解**

#### 1. **数据预处理**
```python
repo_cover = {
    repo: set(物品列表) 
    for repo in 所有仓库
}
```
- 构建仓库覆盖能力字典
- **示例**：`{"沈阳市": {"Item66", "Item87"}, "秦皇岛市": {"Item54", "Item99"}}`

#### 2. **回溯框架**
```python
def backtrack(current_select_repos, uncovered_items):
    # 终止条件：所有物品已覆盖
    if not uncovered_items: 
        # 记录最优解
        return
    
    # 状态缓存检查
    state = (已选仓库集合, 未覆盖物品集合)
    if state in visited: 
        return
    
    # 贪心选择候选仓库（剪枝关键）
    candidate_repos = 能覆盖最多未覆盖物品的仓库列表
    
    # 递归探索
    for repo in candidate_repos:
        new_uncovered = 剩余未覆盖物品 - 当前仓库覆盖物品
        backtrack(已选仓库+[repo], new_uncovered)
```

#### 3. **剪枝策略**
- **贪心优先级**：始终优先选择能覆盖最多剩余物品的仓库（减少递归深度）
- **状态去重**：通过 `visited` 集合缓存 `(已选仓库, 未覆盖物品)` 状态，避免重复计算
- **长度剪枝**：当已选仓库数超过当前最优解时停止搜索该路径

---

### **时间复杂度优化分析**
| 优化策略           | 效果说明                                                                 |
|--------------------|--------------------------------------------------------------------------|
| 贪心候选选择       | 将分支因子从O(N)降为O(k)，k为当前最优候选仓库数                          |
| 状态缓存           | 避免重复计算相同状态，空间换时间                                         |
| 最优解长度剪枝     | 当已选仓库数 ≥ 当前最小覆盖数时提前终止搜索                              |
| 覆盖物品实时更新   | 通过集合运算快速计算剩余未覆盖物品，时间复杂度O(1)                       |

---

### **业务应用示例**
假设有以下成本数据：
| 仓库       | 运营成本（万元/月） |
|------------|---------------------|
| 沈阳市     | 120                 |
| 秦皇岛市   | 95                  |
| 乌海市     | 80                  |
| 营口市     | 110                 |
| 运城市     | 75                  |

基于函数输出的三个候选方案：
1. `['沈阳市', '秦皇岛市', '乌海市']` → 总成本 120+95+80=295万
2. `['沈阳市', '秦皇岛市', '营口市']` → 总成本 120+95+110=325万 
3. `['沈阳市', '秦皇岛市', '运城市']` → 总成本 120+95+75=290万

**决策建议**：选择第三个方案，在满足最小仓库数的前提下实现成本最低。

---

### **异常处理机制**
| 异常类型       | 触发条件                  | 处理方式                     |
|----------------|---------------------------|------------------------------|
| ValueError     | 输入邻接矩阵为空          | 终止流程，提示数据错误       |
| 隐式错误       | 物品无任何仓库可覆盖      | 函数返回空列表（需外围校验） |


### `calculate_cost()` 函数 <a id="calculate_cost-函数"></a>


#### **功能描述**
该函数是供应链成本核算模块的核心组件，**针对单条运输路线和指定采购量，计算包含运输与仓储的全链路成本**。主要功能包括：

1. **复合成本计算**  
   综合考量运输环节和仓储环节的费用，计算公式：  
   `总成本 = (单次运输成本 + 单位商品仓储成本) × 购买数量`

2. **业务逻辑验证**  
   - 校验购买数量合法性
   - 验证运输记录数据完整性
   - 确保成本数值符合财务规范

3. **成本明细解构**  
   明确区分运输成本（一次性费用）与仓储成本（按量计费），支持成本分析

---

#### **参数说明**
| 参数名         | 类型               | 必填 | 说明                                                                 |
|----------------|--------------------|------|----------------------------------------------------------------------|
| count          | int/float          | 是   | 当前订单的采购数量，需>0                                            |
| trans_record   | pandas.DataFrame   | 是   | 单条运输路线数据（来自候选仓库筛选结果），需包含成本相关字段         |

**运输记录字段要求**：
- 必需列：`["运输成本（元）", "目的地仓储成本（元）"]`
- 数据约束：数值≥0，建议为单行数据（多行时默认取首行）

---

#### **返回值**
返回 **订单总成本**（浮点数/整数），计算逻辑：  
```python
总成本 = (运输成本 + 单位仓储成本) × 采购数量
```
**计算示例**：  
- 运输成本=50元，仓储成本=2元/件，采购量=100  
- 总成本 = (50 + 2) × 100 = 5200元

---

#### **异常处理机制**
| 异常类型         | 触发条件                          | 处理建议                     |
|------------------|-----------------------------------|------------------------------|
| ValueError       | 采购数量≤0或非数值                | 检查订单输入系统             |
| ValueError       | 运输记录为空                      | 验证前置筛选逻辑是否遗漏数据 |
| KeyError         | 缺失运输/仓储成本列               | 核查数据管道字段映射         |
| ValueError       | 运输或仓储成本为负数/无效数据类型 | 审计财务数据录入规范         |

---
### `output_best_routes()` 函数 <a id="output_best_routes-函数"></a>

#### **功能描述**
该函数是供应链路径优化的最终决策模块，**基于最小仓库覆盖集合，计算每个仓库组合的总运输成本，并选择成本最低的运输方案**。核心功能包括：

1. **多方案成本对比**  
   遍历所有最小覆盖仓库组合，计算每个组合的运输总成本，筛选全局最优解

2. **细粒度路径规划**  
   为每个商品分配具体仓库和运输方式，生成可执行的物流方案

3. **异常商品检测**  
   识别无法满足需求的商品，提供问题定位依据

---

#### **参数说明**
| 参数名             | 类型               | 必填 | 说明                                                                 |
|--------------------|--------------------|------|----------------------------------------------------------------------|
| orders             | pandas.DataFrame   | 是   | 原始订单数据表，需包含商品、数量、目的地                             |
| candidate_repos    | pandas.DataFrame   | 是   | 预筛选的候选仓库及运输路线数据                                       |
| adjacency_matrix   | pandas.DataFrame   | 是   | 仓库-物品可达性矩阵                                                  |
| minimal_cover      | List[List[str]]    | 是   | 最小仓库覆盖集合（多个候选方案）                                     |

---

#### **返回值**
返回三元组 `(best_routes, total_cost, item_details)`：

| 返回值项          | 类型             | 说明                                                                 |
|-------------------|------------------|----------------------------------------------------------------------|
| best_routes       | List[str]        | 最优仓库组合（如 `['沈阳市', '秦皇岛市', '乌海市']`）               |
| total_cost        | float            | 对应仓库组合的总运输成本（单位：元）                                 |
| item_details      | Dict[str, Dict]  | 每个商品的详细运输方案（仓库、目的地、成本、运输方式）               |

---

#### **核心逻辑分步解析**

1. **数据预处理与校验**
   ```python
   # 输入数据完整性校验
   if orders.empty or ... : raise ValueError(...)
   # 提取订单关键字段
   orders_items, orders_destination, orders_counts, _ = get_orders(orders)
   ```
   - 防御性检查确保数据管道可靠性
   - 忽略时限字段（`_`）因成本计算不依赖时效约束

2. **仓库组合去重**
   ```python
   unique_cover = []
   seen_combinations = set()
   for repos_set in minimal_cover:
       sorted_repos_set = tuple(sorted(repos_set))
       if sorted_repos_set not in seen_combinations:
           unique_cover.append(repos_set)
   ```
   - 消除顺序不同但仓库相同的重复组合
   - 示例：`['A','B']` 与 `['B','A']` 视为同一方案

3. **成本优化计算**
   ```python
   for repos_set in unique_cover:
       current_cost = 0
       item_to_repo = {}
       temp_item_details = {}
       
       for item, count, destination in zip(...):
           # 查找可用仓库
           for repo in repos_set:
               if adjacency_matrix.loc[item, repo] == 1:
                   # 获取运输记录并计算成本
                   trans_record = candidate_repos[...]
                   total_item_cost = calculate_cost(...)
           # 记录最优仓库
           current_cost += min_item_cost
   ```
   - 双层循环结构：外层遍历仓库组合，内层遍历订单商品
   - 动态规划思想：为每个商品选择当前组合中的最优仓库

4. **最优解更新**
   ```python
   if current_cost < total_cost:
       total_cost = current_cost
       best_routes = repos_set
       item_details = temp_item_details
   ```
   - 实时保留历史最优解
   - 完整记录商品级运输详情

---

#### **示例输出解析**
```python
最优仓库组合： ['沈阳市', '秦皇岛市', '乌海市']
最小总成本: 2954.74 元

商品详情：
{
    "Item66": {
        "始发地": "沈阳市",
        "目的地": "张家口市",
        "成本": 280.24,
        "运输途径": "飞机"
    },
    "Item99": {
        "始发地": "秦皇岛市",
        "目的地": "抚顺市",
        "成本": 151.37,
        "运输途径": "汽车"
    },
    ...
}
```
- **成本构成**：每个商品的成本已包含运输成本与仓储成本
- **路径选择**：同一仓库组合内自动选择最优运输方式（如 `Item99` 选择汽车运输）

---

#### **异常处理机制**
| 异常类型         | 触发条件                          | 处理方式                     |
|------------------|-----------------------------------|------------------------------|
| ValueError       | 输入数据为空                      | 终止计算并提示具体空数据源   |
| 隐式错误         | 商品无可用仓库                    | 记录到 `unsatisfied_items`  |
| 数据一致性错误   | 候选仓库数据与邻接矩阵不匹配      | 跳过无效仓库并打印警告       |

---
### 结果示例 <a id="result-example"></a>
```python

候选仓库记录：
      物品编号    始发地   目的地  库存  所需时间（小时）  目的地仓储成本（元）  运输成本（元） 运输途径
0   Item66    沈阳市  张家口市  35      8.03       11.41   23.620   飞机
1   Item66    邯郸市  张家口市  92      8.11       11.41   56.800   飞机
2   Item66   石家庄市  张家口市  69     17.51       11.41   15.740   火车
3   Item99    深圳市   抚顺市  71     17.51       20.05   18.340   火车
4   Item99    苏州市   抚顺市  22     11.40       20.05   19.950   火车
5   Item99    泰州市   抚顺市  52      4.58       20.05   20.640   汽车
6   Item99    淮安市   抚顺市  18     17.97       20.05   61.152   汽车
7   Item99    保定市   抚顺市  22      9.18       20.05   22.030   火车
8   Item99   秦皇岛市   抚顺市  26     22.13       20.05   10.224   汽车
9   Item99    邯郸市   抚顺市  18      0.53       20.05    7.580   火车
10  Item99    邢台市   抚顺市  22     23.91       20.05   24.270   火车
11  Item99    阳泉市   抚顺市  14     21.54       20.05   17.892   汽车
12  Item38    乌海市   上海市  19      5.96       52.99   10.500   飞机
13  Item38    营口市   上海市  59     16.95       52.99   24.870   火车
14  Item38    运城市   上海市  76      3.62       52.99   32.150   火车
15  Item54    南京市   大连市  48      6.13       50.66    7.530   火车
16  Item54   秦皇岛市   大连市  89     18.61       50.66   25.650   火车
17  Item54  呼伦贝尔市   大连市  31      9.37       50.66   34.100   飞机
18  Item87    上海市   阳泉市  29      6.03       16.92   23.870   火车
19  Item87    承德市   阳泉市  87      5.15       16.92   34.860   飞机
20  Item87    沈阳市   阳泉市  18     18.23       16.92   19.344   汽车

邻接矩阵：
        沈阳市  邯郸市  石家庄市  深圳市  苏州市  泰州市  淮安市  保定市  秦皇岛市  邢台市  阳泉市  乌海市  营口市  运城市  南京市  呼伦贝尔市  上海市  承德市
Item66    1    1     1    0    0    0    0    0     0    0    0    0    0    0    0      0    0    0
Item99    0    1     0    1    1    1    1    1     1    1    1    0    0    0    0      0    0    0
Item38    0    0     0    0    0    0    0    0     0    0    0    1    1    1    0      0    0    0
Item54    0    0     0    0    0    0    0    0     1    0    0    0    0    0    1      1    0    0
Item87    1    0     0    0    0    0    0    0     0    0    0    0    0    0    0      0    1    1

最小覆盖的候选集合：
[['沈阳市', '秦皇岛市', '乌海市'], ['沈阳市', '秦皇岛市', '营口市'], ['沈阳市', '秦皇岛市', '运城市']]

最优仓库组合： ['沈阳市', '秦皇岛市', '乌海市']
最小总成本: 2954.74 元

每个商品的详细信息：
 Item66 [一次性口罩（200片装）]: 沈阳市 → 张家口市 成本: 280.24 元 运输途径: 飞机
 Item99 [一次性洗面奶（旅行装）]: 秦皇岛市 → 抚顺市 成本: 151.37 元 运输途径: 汽车
 Item38 [便携式电热水壶]: 乌海市 → 上海市 成本: 1015.84 元 运输途径: 飞机
 Item54 [一次性化妆棉（100片装）]: 秦皇岛市 → 大连市 成本: 1144.65 元 运输途径: 火车
 Item87 [一次性化妆刷套装]: 沈阳市 → 阳泉市 成本: 362.64 元 运输途径: 汽车
```


